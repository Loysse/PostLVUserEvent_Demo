/**
 * @file skeleton_lv_event.cpp
 *
 * @author
 *
 * @date
 *
 *
 *
 */

#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <errno.h>
#include <signal.h>

#include <windows.h>
#include <process.h>

/* LabVIEW include */
#include "extcode.h"

/* LabVIEW string length generated */
#define STRING_LENGTH	256

/**
 * Thread parameter
 */
struct _st_async_function_parameters
{
	int32_t a;	/**< First operand */
	int32_t b;	/**< Second operand */

	int64_t sum; /**!< Store the result */

	LVUserEventRef *ref; /**< Labview event associated */

	MgErr lv_err; /**< PostEventError */

	int64_t count; /** Count thread call */

	int running;	/**< flag thread is running */
	HANDLE hthread;	/**< handle to the thread */
};

/**
 * Function generating an event with the sum's result representation with a string
 *
 * @param pParam thread parameter
 *
 * @return end thread status
 */
static unsigned __stdcall
		SKL_SumToStringEvent(void *pParam)
{
	/* Converted thread parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	/* Call count */
	param->count++;

	/* Evaluated the sum */
	param->sum = param->a + param->b;

	/* Generating a LabVIEW string in C */
	LStrHandle newStringHandle;
	newStringHandle=(LStrHandle)DSNewHandle(sizeof(int32)+STRING_LENGTH*sizeof(uChar));
	memset(LStrBuf(*newStringHandle),'\0',STRING_LENGTH);

	/* Populate the LabVIEW string with the sum's result representation */
	snprintf((char *)LStrBuf(*newStringHandle), STRING_LENGTH, "%d", param->sum);

	/* Evaluate the string length for the LabVIEW representation */
	LStrLen(*newStringHandle)=strlen((char *)LStrBuf(*newStringHandle));

	/* Generated the event */
	param->lv_err = PostLVUserEvent( *param->ref, &newStringHandle);
	if (param->lv_err != mgNoErr)
	{
		/* Failed */
	}

	/* Thread is finished */
	param->running = 0;

	return 0;
}

/**
 * Function generating an event with the sum's result
 *
 * @param pParam thread parameter
 *
 * @return end thread status
 */
static unsigned __stdcall
		SKL_SumEvent(void *pParam)
{
	/* Converted thread parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	/* Call count */
	param->count++;

	/* Evaluated the sum */
	param->sum = param->a + param->b;

	/* Generated the event */
	param->lv_err = PostLVUserEvent( *param->ref, (void *)&param->sum);
	if (param->lv_err != mgNoErr)
	{
		/* Failed */
	}

	/* Thread is finished */
	param->running = 0;

	return 0;
}

/**
 * Function generating periodically an event with the the sum's result accumulation
 *
 * @param pParam thread parameter
 *
 * @return end thread status
 */
static unsigned __stdcall
		SKL_RepeatSum(void *pParam)
{
	/* Converted thread parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	/* Initiliase the accumulation variable */
	param->sum = 0;

	/* While the thread is mark as running */
	while(param->running)
	{
		/* Repeat count */
		param->count++;

		/* Evaluated the sum's result accumulation  */
		param->sum += param->a + param->b;

		/* Generated the event */
		param->lv_err = PostLVUserEvent( *param->ref, &param->sum);
		if (param->lv_err != mgNoErr)
		{
			/* Failed */
			break;
		}

		/* Waiting 1s */
		Sleep(1000);
	}

	return 0;
}

/**
 * Function returning the parameters sum
 *
 * @param a first operand
 * @param b second operand
 *
 * @return a + b sum
 */
__declspec(dllexport) int32_t __stdcall
		SKL_SyncFunction(int32_t a, int32_t b)
{
	return a + b;
}

/**
 * Stopping thread generated by the SKL_AsyncRepeatSum call
 *
 * @param pParm equivalent to the thread parameters
 */
__declspec(dllexport) void __stdcall
		SKL_Stop(uint64_t pParam)
{
	/* Converted parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	/* Change thread state to stop  state*/
	param->running = 0;

	/* Waiting the thread stops */
	WaitForSingleObject( param->hthread, INFINITE );

	/* Free thread parameter */
	free(param);
}

/**
 * Return the thread count variable
 *
 * @param pParam thread handle
 */
__declspec(dllexport) int64_t __stdcall
		SKL_Thread_Count(uint64_t pParam)
{
	/* Converted parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	return param->count;
}

/**
 * Return the thread running variable
 *
 * @param pParam thread handle
 */
__declspec(dllexport) int64_t __stdcall
		SKL_Thread_Running(uint64_t pParam)
{
	/* Converted parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	return param->running;
}

/**
 * Return the thread sum variable
 *
 * @param pParam thread handle
 */
__declspec(dllexport) int64_t __stdcall
		SKL_Thread_Sum(uint64_t pParam)
{
	/* Converted parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	return param->sum;
}

/**
 * Return the thread lv_err variable
 *
 * @param pParam thread handle
 */
__declspec(dllexport) int64_t __stdcall
		SKL_Thread_LvErr(uint64_t pParam)
{
	/* Converted parameter */
	struct _st_async_function_parameters *param = (struct _st_async_function_parameters *)pParam;

	return param->lv_err;
}

/**
 * Function returning the parameters sum with a LabVIEW event. The function SKL_Stop must be called to free the handle memory.
 *
 * @param a first operand
 * @param b second operand
 * @param ref LabVIEW reference event pointer
 *
 * @return handle to managed the thread associated.
 */
__declspec(dllexport) uint64_t  __stdcall
		SKL_AsyncSum(int32_t a, int32_t b, LVUserEventRef *ref)
{
	struct _st_async_function_parameters *param;

	/* Allocated thread parameters memory */
	param = (struct _st_async_function_parameters *)malloc(sizeof *param);
	if (param == NULL)
	{
		return 0;
	}
	else
	{
		/* Populated the thread parameters */
		param->a = a ;
		param->b = b ;
		param->ref = ref ;

		/* Initialise counter and error variables */
		param->count = 0;
		param->lv_err = mgNoErr;

		/* Thread is mark as running */
		param->running = 1;

		/* Launched the thread */
		param->hthread = (HANDLE)_beginthreadex(NULL, 0, SKL_SumEvent, (void *)param, 0, NULL );
		if ( param->hthread == NULL)
		{
			free(param);
			param = NULL;
		}
	}

	/* Return the thread parameters as handle */
	return (uint64_t)param;
}

/**
 * Function returning the parameters sum with a LabVIEW event in string format. The function SKL_Stop must be called to free the handle memory.
 *
 * @param a first operand
 * @param b second operand
 * @param ref LabVIEW reference event pointer
 *
 * @return handle to managed the thread associated.
 */
__declspec(dllexport) uint64_t  __stdcall
		SKL_AsyncSumToString(int32_t a, int32_t b, LVUserEventRef *ref)
{
	struct _st_async_function_parameters *param;

	/* Allocated thread parameters memory */
	param = (struct _st_async_function_parameters *)malloc(sizeof *param);
	if (param == NULL)
	{
		return 0;
	}
	else
	{
		/* Populated the thread parameters */
		param->a = a ;
		param->b = b ;
		param->ref = ref ;

		/* Initialise counter and error variables */
		param->count = 0;
		param->lv_err = mgNoErr;

		/* Thread is mark as running */
		param->running = 1;

		/* Launched the thread */
		param->hthread = (HANDLE)_beginthreadex(NULL, 0, SKL_SumToStringEvent, (void *)param, 0, NULL );
		if ( param->hthread == NULL)
		{
			free(param);
			param = NULL;
		}
	}

	/* Return the thread parameters as handle */
	return (uint64_t)param;
}

/**
 * Function returning the accumulation parameters sum with a LabVIEW event. The function SKL_Stop must be called to free the handle memory.
 *
 * @param a first operand
 * @param b second operand
 * @param ref LabVIEW reference event pointer
 *
 * @return handle to managed the thread associated.
 */
__declspec(dllexport) uint64_t  __stdcall
		SKL_AsyncRepeatSum(int32_t a, int32_t b, LVUserEventRef *ref)
{
	struct _st_async_function_parameters *param;

	/* Allocated thread parameters memory */
	param = (struct _st_async_function_parameters *)malloc(sizeof *param);
	if (param == NULL)
	{
		return 0;
	}
	else
	{
		/* Populated the thread parameters */
		param->a = a ;
		param->b = b ;
		param->ref = ref ;

		/* Initialise counter and error variables */
		param->count = 0;
		param->lv_err = mgNoErr;

		/* Thread is mark as running */
		param->running = 1;

		/* Launched the thread */
		param->hthread = (HANDLE)_beginthreadex(NULL, 0, SKL_RepeatSum, (void *)param, 0, NULL );
		if ( param->hthread == NULL)
		{
			free(param);
			param = NULL;
		}
	}

	/* Return the thread parameters as handle */
	return (uint64_t)param;
}

/**
 * Dll Main
 */
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,  /* handle to DLL module */
    DWORD fdwReason,     /* reason for calling function */
    LPVOID lpReserved )  /* reserved */
{
    /* Perform actions based on the reason for calling. */
    switch( fdwReason )
    {
        case DLL_PROCESS_ATTACH:
         /* Initialize once for each new process. */
            break;

        case DLL_THREAD_ATTACH:
         /* Do thread-specific initialization. */
            break;

        case DLL_THREAD_DETACH:
         /* Do thread-specific cleanup. */
            break;

        case DLL_PROCESS_DETACH:
         /* Perform any necessary cleanup. */
            break;
    }

    return TRUE;  /* Successful DLL_PROCESS_ATTACH. */
}

